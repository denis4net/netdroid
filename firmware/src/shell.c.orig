/**
 * @author Denis Vashchuk
 * @brief Implementation of shell function, uart2 initialization, command handeling
 * @copyright BSUIR 2013
 */
#include <stm32f10x.h>
#include <stm32f10x_rcc.h>
#include <stm32f10x_usart.h>
#include <string.h>
#include "shell.h"
#include "uart.h"

static int (*cmd_handler)(const char* cmd);

int shell_init(int  (*handler)(const char*))
{
    cmd_handler = handler; //set local cmd handler
    usart_init();
}

void USART1_IRQHandler()
{
    __NOP();
    return;
}

void  USART2_IRQHandler()
{
    static uint8_t buffer[CMD_SIZE];
    static uint16_t char_number;
    static uint8_t received_byte;


    uint32_t reg = USART2->SR;

    if(  USART_GetITStatus(USART2, USART_IT_RXNE)  )   //check irq source, data received
        {
            received_byte = USART2->DR;
            usart_send_byte(received_byte);		// echo to console

            buffer[char_number] = received_byte;

            if( (char)received_byte == '\b')
                {
                    char_number--;
                }
            else if( (char) received_byte == '\r' )
                {
                    usart_send_byte('\n');
                    buffer[char_number]='\0'; //set end of null terminated string
                    cmd_handler(buffer);
                    char_number=0;
                }
            else
                {
                    char_number++;
                }

            USART_ClearITPendingBit(USART2, USART_IT_RXNE);
            GPIO_ResetBits(GPIOB, GPIO_Pin_0);
        }

    if((USART1->SR & USART_SR_TXE)!=0)
        {
            USART1->SR &= ~USART_SR_TXE;         //очистить флаг
            if( usart_buff_tx_pos < usart_buff_txe_pos )
                USART1->DR = usart_buff_tx[usart_buff_tx_pos++];
            else
                {
                    USART1->CR1 &= ~USART_CR1_TXEIE;
                    usart_buff_txe_pos = 0;
                    usart_buff_tx_pos = 0;
                }
        }
    //если причина прерывания  окончание передачи
    if((USART1->SR & USART_SR_TC)!=0)
        {
            USART1->SR &= ~USART_SR_TC;         //очистить флаг
        }

}

